---
title: "urchin_bioerosion"
author: "Noam Altman-Kurosaki"
date: "2024-10-21"
output: html_document
---

```{r setup, include=FALSE}
rm(list=ls()) # clean up
library(knitr)
library(plyr)
library(dplyr)
library(car)
library(reshape)
library(reshape2)
library(effects)
library(MASS)
library(tidyr)
library(MuMIn)
library(mgcv)
library(sp)
library(vegan)
library(ggplot2)
library(ggbreak)
library(ggpubr)
library(glmmTMB)
library(emmeans)
library(DHARMa)
library(metafor) # for metaanalysis
library(stringr)
library(here)
library(tidyverse) # data manipulation
library(patchwork) # combining figures
library(sf) # working with georeferenced objects
library(rnaturalearth) # map of the world
library(rnaturalearthdata)
opts_chunk$set(comment="  ",
               collapse=TRUE, 
               echo=FALSE,
               #fig.asp=1/gr,
               fig.height=8,
               fig.width = 10,
               dev="png",
               warning=TRUE
               
               )
options("print.matrix" = FALSE)
opts_knit$set(eval.after = "fig.cap") 
```

```{r functions}
# create function for standard error
se = function(x){
  sd(x, na.rm = TRUE)/sqrt(length(x))
}

# Function to calculate convex hull
find_hull <- function(df) {
  df[chull(df$NMDS1, df$NMDS2), ]
}


# truncated normal - from https://stats.stackexchange.com/questions/113230/generate-random-numbers-following-a-distribution-within-an-interval
rtruncnorm <- function(N, mean = 0, sd = 1, a = -Inf, b = Inf) {
  if (a > b) stop('Error: Truncation range is empty');
  U <- runif(N, pnorm(a, mean, sd), pnorm(b, mean, sd));
  qnorm(U, mean, sd); }

```

```{r plot aesthetics}
my_theme <-     theme_classic() +
      theme(axis.title.x = element_text(size=24, colour = "black"), 
        axis.title.y = element_text(size=24, colour = "black"), 
        axis.text.x = element_text(size=22, colour = "black"), 
        axis.text.y = element_text(size=22, colour = "black"),
        legend.text = element_text(size=22, colour = "black"),
        plot.title = element_text(size=26), 
        panel.background = element_blank(), 
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_rect(fill = "white"),
        legend.title = element_text(size=24, colour = "black"),
        legend.position = 'bottom', # move legend to bottom
        legend.box = 'horizontal', # make legend horizontal
        legend.box.background = element_rect(colour = "black"))  # add box around legend
```

```{r lit timeline}
## ADAPTED FROM CODE FROM J. RENZI

lit <- read.csv(here::here("data", "paper_list.csv"))

# get the count of publications per year
time_sum <- lit %>% 
  group_by(year, focus) %>% 
  summarize(study = n()) 

# get the duration of the graph we want (from the first study to the last)
min_yr <- 1967
max_yr <- 2024

# create a dataframe of all possible values to join so that every year is accounted for (year=0 if there are no publications)
all_years <- data.frame(year = c(seq(min_yr, max_yr, by = 1),
                                seq(min_yr, max_yr, by = 1),
                                seq(min_yr, max_yr, by = 1)),
                        focus = c(rep("erosion", times = max_yr-min_yr+1),
                                     rep("herbivory", times = max_yr-min_yr+1),
                                     rep("both", times = max_yr-min_yr+1))) 

# join the dataframes so there's a line for every year
time_full <- all_years %>% 
  full_join(time_sum, by = c("year", "focus")) %>% # join the two dataframes so there's a line for every year
  mutate(study = replace_na(study, 0)) # replace the NA's for 0 in the years where nothing was published

(time_plt <-
  ggplot(data = time_full, aes(x = year, y = study, fill = fct_reorder(focus, desc(focus)))) + # fct_reorder() so both is the last in the legend (makes the most sense)
  geom_bar(stat = "identity") + # identity means to use the values in the cells for plotting
  ylab("Number of studies") +
  geom_hline(yintercept = 0) + # create an x-axis that is distinct
  theme_minimal()  +
  scale_fill_manual(name = "", # no legend title 
                    limits = c("erosion", "herbivory", "both"),
                    values = c("darkgoldenrod1",   "brown3", "darkorange4"),
                    labels = c("herbivory" = "Herbivory", "erosion" = "Erosion", "both" = "both")) +
  scale_x_continuous(breaks = seq(min_yr, max_yr, by = 2)) + # get higher resolution ticks on the x-axis
  labs(title = "a.") +
  theme(text = element_text(size = 15), legend.position = "top",
        axis.text.x = element_text(angle = 90, hjust = 1), # rotate axis labels
        axis.title.x = element_text(vjust = -1), # add padding fo titles (also need to adjust the margins)
        axis.title.y = element_text(vjust = 3),
        plot.margin = unit(c(5.5, 5.5, 10, 10), "points")) )

```

```{r map}
# bring in world shape
world <- ne_countries(scale = "medium", returnclass = "sf")

# bring in shapefiles from Spalding et al. on marine bioregions
meow_ecos <- read_sf(here::here("data", "Marine_Ecoregions_Of_the_World_(MEOW)-shp"))

# check that projections match
# st_crs(world)
# st_crs(meow_ecos) # both WGS84 but specified differently... 
# coerce coordinate systems
world <- st_transform(world, crs = 4326)

lit_expanded <- lit %>%
  separate_rows(ecoregion, sep = ";") %>%  # Split multiple ecoregions into separate rows
  mutate(Ecoregion = base::trimws(ecoregion))   # Remove any leading/trailing whitespace
lit_expanded$Ecoregion <- trimws(lit_expanded$ecoregion) # need to re-run the trim whitespace for some reason


# get count of number of studies per ecoregion
ecoreg_sum <- lit_expanded %>% 
  group_by(Ecoregion) %>% 
  summarize(num_studies = n()) %>% 
  mutate(ECOREGION = Ecoregion) # make name match that in meow_ecos

meow_pub <- meow_ecos %>% 
  left_join(ecoreg_sum, by = "ECOREGION")

# coerce to match coordinate system of world
meow_pub <- st_transform(meow_pub, crs = 4326)

(ecoreg_plt <- ggplot() +
  # color the ecoregions based on the number of studies they have
  geom_sf(data = meow_pub, aes(fill = num_studies), color = NA, linewidth = 0) +
  geom_sf(data = world, fill = "black", color = "black", size = 0.05) + # background color for continents (black)
  theme_bw() +
  # format legend and color scheme
 scale_fill_gradient(name = "Number of studies", 
                    low = "yellow", 
                    high = "brown3", 
                    na.value = NA,
                    limits = c(1, 50),  # Fix the scale to match the original
                    breaks = seq(0, 49, by = 10)) + 
  labs(title = "b.") +
  theme(text = element_text(size = 15)) + # increase text size
  coord_sf(xlim = c(-180, 180), ylim = c(-90, 90), expand = FALSE) +
  theme(panel.grid.major = element_line(colour = 'grey50', size = 0.2, linetype = 3))) # add grid lines 
```



```{r repeat map with just erosion}
erosion_lit <- subset(lit_expanded, focus != "herbivory")



# get count of number of studies per ecoregion
erosion_ecoreg_sum <- erosion_lit %>% 
  group_by(Ecoregion) %>% 
  summarize(num_studies = n()) %>% 
  mutate(ECOREGION = Ecoregion) # make name match that in meow_ecos

meow_erosion_pub <- meow_ecos %>% 
  left_join(erosion_ecoreg_sum, by = "ECOREGION")

# coerce to match coordinate system of world
meow_erosion_pub <- st_transform(meow_erosion_pub, crs = 4326)

(ecoreg_erosion_plt <- ggplot() +
  geom_sf(data = meow_erosion_pub, aes(fill = num_studies), color = NA, linewidth = 0) +
  geom_sf(data = world, fill = "black", color = "black", size = 0.05) + 
  theme_bw() +
scale_fill_gradient(name = "Number of studies", 
                    low = "yellow", 
                    high = "brown3", 
                    na.value = NA,
                    limits = c(1, 50),  # Fix the scale to match the original
                    breaks = seq(0, 49, by = 10)) +
  theme(text = element_text(size = 15)) + # increase text size
  labs(title = "c.") +
  coord_sf(xlim = c(-180, 180), ylim = c(-90, 90), expand = FALSE) +
  theme(panel.grid.major = element_line(colour = 'grey50', size = 0.2, linetype = 3))) # add grid lines 
```

```{r lit review panel, fig.height=12, fig.width = 10}
(lit_panel <- ggpubr::ggarrange(time_plt, ggarrange(ecoreg_plt,
                                                    ecoreg_erosion_plt, nrow = 2, common.legend = TRUE,  legend = "right"),
                                nrow = 2, heights = c(1, 2), ncol = 1))
# ggsave(filename = "output/lit_review_summary_panel_v2.png", lit_panel, height = 12, width = 10)
```

```{r lit urchin summary stats}
lit_urchins <- lit %>%
  separate_rows(focal_species, sep = ";") %>%  # Split urchins
  mutate(focal_species = trimws(focal_species))   # Remove any leading/trailing whitespace

# get list of species alphabetically
lit_urchins_list <- sort(unique(lit_urchins$focal_species))

# get list of erosion ecoregions
erosion_ecoreg_list <- sort(unique(droplevels(subset(lit_expanded, focus != "herbivory"))$Ecoregion))

```

```{r prep urchin field data}

# read in data
comb <- read.csv(here::here("data", "urchin_data.csv"), stringsAsFactors = T)
comb$Species.code <- str_trim(comb$Species.code) # remove any excess spaces from the end of species codes
levels(as.factor(comb$Species.code))


comb$Size <- as.numeric(comb$Size) # coerce size into as numeric
comb$SL <- comb$aL + comb$bL * comb$Size # convert TL to SL for biomass conversions
comb$biomass.ind <- comb$a * comb$SL^comb$b # biomass = aL^b
comb$Rugosity <- 10/comb$Rugosity # convert rugosity to rugosity index over 10m
comb$Depth_m <- comb$Depth/3.281

# Only interested in urchins (community of interest), herbivorous fish (competitors), urchin predators
relevant_data <- subset(comb, Diet == "Herbivore" | Diet == "Urchin" | Diet == "Urchin predator") 

relevant_data_exp <- untable(relevant_data, relevant_data$Count) # expand table so each row is an individual urchin
zeroes <- subset(relevant_data, Count == 0)  # Retain transects with no individuals of a given species
urchins_zeroes <- subset(zeroes, Diet == "Urchin") # Specifically keep urchin species from the zero transects
urchins_exp <- subset(relevant_data_exp, Diet == 'Urchin') # subset urchins from expanded table

# randomly sample urchins to from existing size distributions to fill in "just count" urchins
set.seed(1032)
for(i in 1:nrow(urchins_exp)){ # for each individual
  if(is.na(urchins_exp$Size[i])){ # if the size is an NA it was an usized count
    urchins_exp$Size[i] = replace_na(urchins_exp$Size[i], # replace that NA
                                      sample(subset(urchins_exp, # by sampling randomly from the expanded dataframe
                                                    !is.na(urchins_exp$Size) & # using urchins that WERE sized/not NAs
                                                      Species.code == urchins_exp$Species.code[i] & # specifically of that species
                                                      Site.ID == urchins_exp$Site.ID[i])$Size, size = 1)) # and from that transect
    
  }
}
urchins_exp <- rbind(urchins_exp, urchins_zeroes) # re-attach zero value transects
# recalculate biomass
urchins_exp$SL <- urchins_exp$aL + urchins_exp$bL*urchins_exp$Size # convert TL to SL for biomass conversions, or urchin test diam from cm to mm
urchins_exp$biomass.ind <- urchins_exp$a * urchins_exp$SL^urchins_exp$b # biomass = aL^b
urchins_exp$Depth_m <- urchins_exp$Depth/3.281 # convert depth from ft to m

# read benthic data
benthic <- read.csv(here::here("data", "benthic_data.csv"))
benthic <- aggregate(. ~ Date+Site.ID+Site+Protection.status+Substrate, data = benthic, FUN = mean)
benthic_meta <- c("Date", "Site.ID", "Site", "Protection.status", "Substrate", "Transect.number", "Depth")


# simplify
# sum up by broader taxonomic group
coral_list <- c('CyphAga', 'LPurp','MCAP','MFLAB','MPATU','PCOM', 'PDAM', 'PEVER','P.mass','PMEAN','PVAR','Soft.coral')
coral <- rowSums(benthic[,coral_list])
invert_list <- c('mob', 'OTH.SINV', 'PALYTHO', 'Tunicate')
invert <- rowSums(benthic[,invert_list])
sponges <- benthic$Prfa
turf <- rowSums(benthic[,c('TURFH', 'RTA')])
sndyTurf <- benthic$SndyTrf
sand <- benthic$Sand
CCA <- benthic$CCA
green_macro_list <- c('HADI','Neo_spp', 'DCav', 'DVers')
green_macro <- rowSums(benthic[,green_macro_list])
brown_macro <- benthic$Dicsp
red_macro_list <- c('Acan', 'ALGA', 'ASPAR', 'GAL', 'GSAL', 'LIA','RAUE', 'LIA', 'KAPPA', 'PRWE', 'RAUE', 'TolyGlom')
red_macro <- rowSums(benthic[,red_macro_list])
cyano_list <- c('CYANO_Sub', 'Lyn_spp')
large_cyano <- rowSums(benthic[,cyano_list])

simplified_benthic <- data.frame(Coral = coral,
                            Invert = invert,
                            Turf = turf,
                            sndyTurf = sndyTurf,
                            Sponges = sponges,
                            Sand = sand,
                            CCA = CCA,
                            Green_Macro = green_macro,
                            Brown_Macro = brown_macro,
                            Red_Macro = red_macro,
                         Large_Cyano = large_cyano)

# simplify macroalgae
simplified_benthic$Macroalgae <- simplified_benthic$Red_Macro + simplified_benthic$Brown_Macro + simplified_benthic$Green_Macro

# simplify turf category
simplified_benthic$Simple_turf <- simplified_benthic$Turf + simplified_benthic$sndyTurf

# turn into proportion
simplified_benthic <- simplified_benthic/100

# add back in metadata
simplified_benthic <- cbind(benthic[,benthic_meta], simplified_benthic)

# create transformed df for ordination later
cover_columns <- colnames(simplified_benthic)[-which(names(simplified_benthic) %in% benthic_meta)]
benthic_trans <- simplified_benthic
benthic_trans[cover_columns] <- lapply(benthic_trans[cover_columns], function(x) asin(sqrt(x)))


```


```{r count analyses set up}
# aggregate counts to get total number of ind for each species per transect
comb_count <- ddply(relevant_data, c("Site","Site.ID", "Protection.status", "Substrate", "Guild", "Species.code", "Species.name", "Transect.number", "Transect.area", "Depth", "Depth_m", "Rugosity", "Diet"), numcolwise(sum))



# calculate density for fish and urchins (different size transects) then recombine
fish <- subset(comb_count, Diet != 'Urchin')
fish$Density <- fish$Count/fish$Transect.area # density = count / area (fish were on a 25 x 5 m transect)
urchins <- subset(comb_count, Diet == 'Urchin')
urchins$Density <- urchins$Count/urchins$Transect.area # urchins were on a 25 x 2 m transect

# for summary stats in paper
count_summaries <- ddply(urchins, c("Guild"), numcolwise(sum))

comb_count <- rbind(fish, urchins) # recombine them

# create wide table at functional group level
guild_density_multi <- cast(comb_count, Site + Site.ID + Protection.status + Substrate + Transect.number + Depth_m+ Rugosity ~ Guild, fun.aggregate = sum, value = "Density")
guild_density_multi$Herbivorous_fish <- guild_density_multi$Scraper + guild_density_multi$Browser + guild_density_multi$Grazer

# for modeling on poisson with offset
guild_count_multi <- cast(comb_count, Site + Site.ID + Protection.status + Substrate + Transect.number + Depth_m+ Rugosity ~ Guild, fun.aggregate = sum, value = "Count") 

guild_count_multi$Herbivorous_fish <- guild_count_multi$Scraper + guild_count_multi$Browser + guild_count_multi$Grazer




# create wide table at species level
species_density_multi <- cast(comb_count, Site + Site.ID + Protection.status + Substrate + Transect.number + Depth_m+ Rugosity ~ Species.name, fun.aggregate = sum, value = "Density")

# create wide table for urchin density
urchin_density_multi <- cast(urchins, Site + Site.ID + Protection.status + Substrate + Transect.number + Depth_m+ Rugosity ~ Species.name, fun.aggregate = sum, value = "Density")


urchin_density_master <- merge(urchin_density_multi, simplified_benthic)
urchin_density_master$Herbivorous_fish <- guild_count_multi$Herbivorous_fish
urchin_density_master$Urchin_predator <- guild_count_multi$`Urchin predator`

# for guild density
urchin_guild_master <- merge(guild_density_multi, simplified_benthic) 

hist(urchin_guild_master$`Boring urchin`)
hist(urchin_guild_master$`Grazing urchin`)




```

```{r grazing urchin model selection}
# coerce grazing and boring urchins back to integers for modeling by multiplying by transect area
urchin_guild_master$grazing_urchin <- urchin_guild_master$`Grazing urchin`*50
urchin_guild_master$boring_urchin <- urchin_guild_master$`Boring urchin`*50

# make depth in m
urchin_guild_master$Depth_m <- urchin_guild_master$Depth/3.281

grazing_pois <- glmmTMB(grazing_urchin ~ Protection.status*Site + Simple_turf + Coral + Macroalgae + CCA + Depth_m+ Herbivorous_fish + `Urchin predator`, family = poisson, data = urchin_guild_master) 
plot(simulateResiduals(grazing_pois)) # overdispersed, non-normal residuals, fails heterogeneity of variance

grazing_nb <- glmmTMB(grazing_urchin ~ Protection.status*Site + Simple_turf + Coral + Macroalgae + CCA + Depth_m+ Herbivorous_fish + `Urchin predator`, family = nbinom2(), data = urchin_guild_master) 
plot(simulateResiduals(grazing_nb)) # no issues

grazing_zi <- glmmTMB(grazing_urchin ~ Protection.status*Site + Simple_turf + Coral + Macroalgae + CCA + Depth_m+ Herbivorous_fish + `Urchin predator`, ziformula = ~Site, family = nbinom2(), data = urchin_guild_master)
plot(simulateResiduals(grazing_zi)) # no issues

AICc(grazing_pois, grazing_nb, grazing_zi) # negative bimomial has best AIC by ~9 over zero inflated despite issues

summary(grazing_nb)
Anova(grazing_nb)
#                          Chisq Df Pr(>Chisq)    
# Protection.status       4.8237  1   0.028071 *  
# Site                   71.4697  3  2.068e-15 ***
# Simple_turf             0.9275  1   0.335511    
# Coral                  16.0637  1  6.125e-05 ***
# Macroalgae              3.9866  1   0.045862 *  
# CCA                     0.9767  1   0.323021    
# Depth                   8.3665  1   0.003822 ** 
# Herbivorous_fish        5.1022  1   0.023895 *  
# `Urchin predator`       2.0896  1   0.148304    
# Protection.status:Site  2.1387  3   0.544124    

emmeans(grazing_nb, pairwise ~ Protection.status | Site)
# $contrasts
# Site = Hanauma:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -0.276 0.545 Inf  -0.507  0.6119
# 
# Site = Kaneohe:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected    0.163 1.447 Inf   0.113  0.9104
# 
# Site = North Shore:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -0.985 0.501 Inf  -1.965  0.0495
# 
# Site = Waikiki:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -1.071 0.557 Inf  -1.925  0.0542
grazing_dens_sig <- c("", "", "*", "")
```

```{r boring model selection}

boring_pois <- glmmTMB(boring_urchin ~ Protection.status*Site + Simple_turf + Coral + Macroalgae + CCA + Depth_m+ Herbivorous_fish + `Urchin predator`, family = poisson, data = urchin_guild_master) 
plot(simulateResiduals(boring_pois)) # looks bad

boring_nb <- glmmTMB(boring_urchin ~ Protection.status*Site + Simple_turf + Coral + Macroalgae + CCA + Depth_m+ Herbivorous_fish + `Urchin predator`, family = nbinom2(), data = urchin_guild_master) 
plot(simulateResiduals(boring_nb)) # overdispersed, positive trend in quantile residual tests

boring_zi <- glmmTMB(boring_urchin ~ Protection.status*Site + Simple_turf + Coral + Macroalgae + CCA + Depth_m+ Herbivorous_fish + `Urchin predator`, ziformula = ~Site, family = nbinom2(), data = urchin_guild_master)
plot(simulateResiduals(boring_zi)) # no problems detected

AICc(boring_pois, boring_nb, boring_zi) # zero inflated best by > 70 over nb

summary(boring_zi)
# Zero-inflation model:
#                  Estimate Std. Error z value Pr(>|z|)    
# (Intercept)      -2.51808    0.60353  -4.172 3.02e-05 ***
# SiteKaneohe       3.65508    0.72036   5.074 3.90e-07 ***
# SiteNorth Shore  -0.01037    0.85765  -0.012    0.990    
# SiteWaikiki     -11.61689  214.19512  -0.054    0.957  

Anova(boring_zi)
#                          Chisq Df Pr(>Chisq)    
# Protection.status       6.6999  1   0.009642 ** 
# Site                   11.6422  3   0.008715 ** 
# Simple_turf            24.2928  1  8.275e-07 ***
# Coral                   8.5145  1   0.003523 ** 
# Macroalgae              1.4179  1   0.233755    
# CCA                     0.1412  1   0.707091    
# Depth                   2.5080  1   0.113269    
# Herbivorous_fish        1.5385  1   0.214839    
# `Urchin predator`       1.2538  1   0.262825    
# Protection.status:Site 31.1702  3  7.827e-07 ***

# pairwise comparisons for site and protection status interaction
emmeans(boring_zi, pairwise ~ Protection.status | Site)
# Site = Hanauma:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -0.756 0.326 Inf  -2.316  0.0205
# 
# Site = Kaneohe:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -2.586 0.801 Inf  -3.230  0.0012
# 
# Site = North Shore:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected    0.556 0.283 Inf   1.967  0.0491
# 
# Site = Waikiki:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -1.306 0.329 Inf  -3.963  0.0001

boring_dens_sig <- c("*", "**", "*", "***")
```

```{r reduced grazing urchin model}
## Refining models to be more specific to our actual questions

grazing_pois_2 <- glmmTMB(grazing_urchin ~ Protection.status*Site + Herbivorous_fish + `Urchin predator`, family = poisson, data = urchin_guild_master) 
plot(simulateResiduals(grazing_pois_2)) # non-normal residuals, violates heterogeneity of variance

grazing_nb_2 <- glmmTMB(grazing_urchin ~ Protection.status*Site + Herbivorous_fish + `Urchin predator`, family = nbinom2(), data = urchin_guild_master) 
plot(simulateResiduals(grazing_nb_2)) # no issues

grazing_zi_2 <- glmmTMB(grazing_urchin ~ Protection.status*Site + Herbivorous_fish + `Urchin predator`, ziformula = ~Site, family = nbinom2(), data = urchin_guild_master)
plot(simulateResiduals(grazing_zi_2)) # no issues

AICc(grazing_pois_2, grazing_nb_2, grazing_zi_2) # zi is best

summary(grazing_zi_2)
#                  Estimate Std. Error z value Pr(>|z|)
# (Intercept)       -0.2348     0.3692  -0.636    0.525
# SiteKaneohe       -0.4744     2.7319  -0.174    0.862
# SiteNorth Shore  -19.5422  6363.6766  -0.003    0.998
# SiteWaikiki       -2.2286     1.5540  -1.434    0.152

Anova(grazing_zi_2)
#                          Chisq Df Pr(>Chisq)    
# Protection.status       5.3582  1    0.02062 *  
# Site                   50.9687  3  4.968e-11 ***
# Herbivorous_fish        1.5629  1    0.21124    
# `Urchin predator`       0.5389  1    0.46288    
# Protection.status:Site 22.8513  3  4.337e-05 ***
# pairwise comparisons for site and protection status interaction

emmeans(grazing_zi_2, pairwise ~ Protection.status | Site)
# Site = Hanauma:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected     1.83 0.720 Inf   2.538  0.0111
# 
# Site = Kaneohe:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected    -1.81 1.260 Inf  -1.436  0.1511
# 
# Site = North Shore:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected    -1.02 0.511 Inf  -2.006  0.0449
# 
# Site = Waikiki:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected    -1.50 0.577 Inf  -2.606  0.0092

grazing_dens_sig <- c("*", "", "*", "**")
```

```{r reduced boring model}

boring_pois_2 <- glmmTMB(boring_urchin ~ Protection.status*Site + Herbivorous_fish + `Urchin predator`, family = poisson, data = urchin_guild_master) 
plot(simulateResiduals(boring_pois_2)) # totally messed up

boring_nb_2 <- glmmTMB(boring_urchin ~ Protection.status*Site + Herbivorous_fish + `Urchin predator`, family = nbinom2(), data = urchin_guild_master) 
plot(simulateResiduals(boring_nb_2)) # some issues in qq and homogeneity

boring_zi_2 <- glmmTMB(boring_urchin ~ Protection.status*Site + Herbivorous_fish + `Urchin predator`, ziformula = ~Site, family = nbinom2(), data = urchin_guild_master)
plot(simulateResiduals(boring_zi_2)) # no issues

AICc(boring_pois_2, boring_nb_2, boring_zi_2) # zi is best

summary(boring_zi_2)

#                   Estimate Std. Error z value Pr(>|z|)    
# (Intercept)       -2.53285    0.61202  -4.139  3.5e-05 ***
# SiteKaneohe        3.63349    0.73194   4.964  6.9e-07 ***
# SiteNorth Shore   -0.03067    0.87806  -0.035    0.972    
# SiteWaikiki      -17.50095 4090.01597  -0.004    0.997    

Anova(boring_zi_2)
#                          Chisq Df Pr(>Chisq)    
# Protection.status      10.3020  1  0.0013289 ** 
# Site                   26.0492  3  9.314e-06 ***
# Herbivorous_fish        5.7067  1  0.0169007 *  
# `Urchin predator`       0.4036  1  0.5252603    
# Protection.status:Site 21.0024  3  0.0001052 ***


emmeans(boring_zi_2, pairwise ~ Protection.status | Site)
# Site = Hanauma:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -1.150 0.316 Inf  -3.642  0.0003
# 
# Site = Kaneohe:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -2.445 0.780 Inf  -3.133  0.0017
# 
# Site = North Shore:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected    0.337 0.314 Inf   1.072  0.2838
# 
# Site = Waikiki:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -0.941 0.341 Inf  -2.757  0.0058

boring_dens_sig <- c("***", "**", "", "**")
```

```{r protection density boxplots, fig.height= 5, fig.width = 8}
(grazing_density_plot <-
   ggplot() +
   geom_boxplot(data = urchin_guild_master, aes(x = Site, y = grazing_urchin, fill = Protection.status),
                outlier.shape = NA) +
   geom_point(data = urchin_guild_master, aes(x = Site, y = grazing_urchin,  fill = Protection.status),
              position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.3)) +
   geom_text(aes(x = c(1, 2, 3, 4), y = rep(45, 4), label = grazing_dens_sig), size = 15) + # add sig stars
   scale_y_break(c(50, 200), space = 0.5) +
    scale_fill_manual(values = c("Protected" = "grey",
                      "Unprotected" = "white")) +
    labs(title = "a. Grazing urchin density", fill = "Protection status", y = bquote('Density (per 50'*m^2*' transect)') ) +
   my_theme
  )
   

(boring_density_plot <-
   ggplot() +
    geom_boxplot(data = urchin_guild_master, aes(x = Site, y = boring_urchin, fill = Protection.status)) +
    geom_point(data = urchin_guild_master, aes(x = Site, y = boring_urchin,  fill = Protection.status),
           position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.3)) +
    geom_text(aes(x = c(1, 2, 3, 4), y = rep(600, 4), label = boring_dens_sig), size = 15) +
    scale_fill_manual(values = c("Protected" = "grey",
                      "Unprotected" = "white")) +
    labs(title = "c. Boring urchin density", fill = "Protection status", y = bquote('Density (per 50'*m^2*' transect)') ) +
    my_theme

  )
   

```

```{r protection panel, fig.height = 11, fig.width=8}
(protection_density_panel <-
   ggarrange(grazing_density_plot, boring_density_plot, nrow = 2, common.legend = T, legend = 'bottom'))
```


```{r density emtrends}
# REMOVED BENTHIC TRENDS ON JAN 31 - SEE VERSION HISTORY FOR THEIR INCLUSION


# Herbivorous_fish
grazing_herb_data <- emmip(grazing_zi_2, ~ Herbivorous_fish, at = list(Herbivorous_fish = seq(0,2,0.01)), CIs = T, plotit = F)
grazing_herb_data$Guild <- rep("Grazing", nrow(grazing_herb_data)) # add guild column for plot
grazing_herb_data$Density <- exp(grazing_herb_data$yvar) # back transform model fit to response scale
grazing_herb_data$lower.CI <- exp(grazing_herb_data$LCL) # repeat for 95% CI
grazing_herb_data$upper.CI <- exp(grazing_herb_data$UCL)

boring_herb_data <- emmip(boring_zi_2, ~ Herbivorous_fish, at = list(Herbivorous_fish = seq(0,2,0.01)), CIs = T, plotit = F)
boring_herb_data$Guild <- rep("Boring", nrow(boring_herb_data)) # add guild column for plot
boring_herb_data$Density <- exp(boring_herb_data$yvar) # back transform model fit to response scale
boring_herb_data$lower.CI <- exp(boring_herb_data$LCL) # repeat for 95% CI
boring_herb_data$upper.CI <- exp(boring_herb_data$UCL)

comb_herb_data <- rbind(grazing_herb_data, boring_herb_data)

# filter ranges
comb_herb_data <- comb_herb_data %>%
  dplyr::filter(Herbivorous_fish >= min(urchin_guild_master$Herbivorous_fish) & 
                  Herbivorous_fish <= max(urchin_guild_master$Herbivorous_fish))

# `Urchin predator`
grazing_pred_data <- emmip(grazing_zi_2, ~ `Urchin predator`, at = list(`Urchin predator` = seq(0,1,0.01)), CIs = T, plotit = F)
grazing_pred_data$Guild <- rep("Grazing", nrow(grazing_pred_data)) # add guild column for plot
grazing_pred_data$Density <- exp(grazing_pred_data$yvar) # back transform model fit to response scale
grazing_pred_data$lower.CI <- exp(grazing_pred_data$LCL) # repeat for 95% CI
grazing_pred_data$upper.CI <- exp(grazing_pred_data$UCL)

boring_pred_data <- emmip(boring_zi_2, ~ `Urchin predator`, at = list(`Urchin predator` = seq(0,1,0.01)), CIs = T, plotit = F)
boring_pred_data$Guild <- rep("Boring", nrow(boring_pred_data)) # add guild column for plot
boring_pred_data$Density <- exp(boring_pred_data$yvar) # back transform model fit to response scale
boring_pred_data$lower.CI <- exp(boring_pred_data$LCL) # repeat for 95% CI
boring_pred_data$upper.CI <- exp(boring_pred_data$UCL)

comb_pred_data <- rbind(grazing_pred_data, boring_pred_data)
# rename column for filtering
colnames(comb_pred_data)[13] <- "Urchin_predator"

# filter ranges
comb_pred_data <- comb_pred_data %>%
  dplyr::filter(Urchin_predator >= min(urchin_guild_master$`Urchin predator`) &
                  Urchin_predator <= max(urchin_guild_master$`Urchin predator`))

```


```{r density environment plots}

(herb_plot <-
  ggplot() +
   geom_point(data = urchin_guild_master, aes(x = Herbivorous_fish, y = grazing_urchin), colour = "skyblue") +
   geom_point(data = urchin_guild_master, aes(x = Herbivorous_fish, y = boring_urchin), colour = "coral") +
   geom_line(data = comb_herb_data, aes(x = Herbivorous_fish, y = Density, colour = Guild), size = 1.5) +
   geom_ribbon(data = comb_herb_data, aes(x = Herbivorous_fish, ymin = lower.CI, ymax = upper.CI, fill = Guild), alpha = 0.5) +
   geom_text(aes(x = 0, y = 500, label = "Grazing: P = 0.21\nBoring: P = 0.02"), hjust = 0, size = 8) +
   scale_colour_manual(values = c("Grazing" = "skyblue",
                      "Boring" = "coral")) +
   scale_fill_manual(values = c("Grazing" = "skyblue",
                      "Boring" = "coral") ) +
   labs(title = "b. Herbivore density", fill = "Urchin guild", colour = "Urchin guild", y = "",
        x = bquote('Herbivore biomass (g '*m^-2*')')) +
   
   my_theme 
 )


(pred_plot <-
  ggplot() +
   geom_point(data = urchin_guild_master, aes(x = `Urchin predator`, y = grazing_urchin), colour = "skyblue") +
   geom_point(data = urchin_guild_master, aes(x = `Urchin predator`, y = boring_urchin), colour = "coral") +
   geom_line(data = comb_pred_data, aes(x = Urchin_predator, y = Density, colour = Guild), size = 1.5) +
   geom_ribbon(data = comb_pred_data, aes(x = Urchin_predator, ymin = lower.CI, ymax = upper.CI, fill = Guild), alpha = 0.5) +
   geom_text(aes(x = 0, y = 500, label = "Grazing: P = 0.46\nBoring: P = 0.52"), hjust = 0, size = 8) +
   scale_colour_manual(values = c("Grazing" = "skyblue",
                      "Boring" = "coral")) +
   scale_fill_manual(values = c("Grazing" = "skyblue",
                      "Boring" = "coral") ) +
   labs(title = "d. Predator density", fill = "Urchin guild", colour = "Urchin guild", y = "",
        x = bquote('Predator biomass (g '*m^-2*')')) +
   
   my_theme 
 )


```

```{r remaining density panel graph, fig.height=12, fig.width=12}
(remaining_density_panel <-
  ggarrange(herb_plot, pred_plot,
            nrow = 2, ncol = 1, common.legend = T, legend = "bottom"))
```

```{r combined density panel, fig.height=10, fig.width= 16}
(full_density_panel <- ggarrange(protection_density_panel, remaining_density_panel, widths = c(1, 1)))
# ggsave(filename = "output/density_panel_graph_v3.png", full_density_panel, height = 10, width = 34)
```

```{r urchin nmds}
# create urchin species matrix
urchin_density_m <- data.matrix(urchin_density_multi[,9:18])

# remove transects with no urchins for ordination
urchin_density_m <- urchin_density_m[ rowSums(urchin_density_m)!=0, ]

# log transform species matrix
urchin_density_m <- log10(urchin_density_m + 1)


  
# remove transects with no urchins from master datasheet for permanova
urchin_density_master_sub <- urchin_density_master[ rowSums(urchin_density_master[,9:18])!=0, ]

# set rownames to site
rownames(urchin_density_m) <- urchin_density_master_sub$Site.ID

set.seed(1032)
ord2 <- metaMDS(urchin_density_m, dist	= "bray",	trymax	= 100,	k	= 2)
ord2 # stress = 0.07 


# ord3 <- metaMDS(urchin_density_m, dist	= "bray",	trymax	= 100,	k	= 3)
# ord3 # stress  = 0.05



cDens.site.scores <- as.data.frame(scores(ord2)$sites)  #Using the scores function from vegan to extract the site scores and convert to a data.frame
cDens.site.scores$Site.ID <- rownames(cDens.site.scores)  # create a column of site names, from the rownames of data.scores
cDens.site.scores$Protection <- urchin_density_master_sub$Protection.status  #  add the protection as a grouping vactor
cDens.site.scores$Site <- urchin_density_master_sub$Site # add the site as another grouping factor
# for stratum ellipses
cDens.site.scores$Stratum <- factor(paste(cDens.site.scores$Site, cDens.site.scores$Protection))



# Calculate convex hull for each Stratum
hull_data <- cDens.site.scores %>%
  group_by(Stratum) %>%
  do(find_hull(.))

cDens.species.scores <- as.data.frame(scores(ord2, "species"))  #Using the scores function from vegan to extract the species scores and convert to a data.frame
cDens.species.scores$species <- rownames(cDens.species.scores)  # create a column of species, from the rownames of species.scores





fit <- envfit(ord2 ~  Herbivorous_fish + Urchin_predator,
              data = urchin_density_master_sub)
env.scores <- as.data.frame(scores(fit, display = "vectors")) #extracts relevant scores from envifit
env.scores <- cbind(env.scores, env.variables = rownames(env.scores)) #and then gives them their names
mult <- 4 # for plotting the envfit


  


vegan::adonis(urchin_density_m ~ Site*Protection.status + Herbivorous_fish + Urchin_predator, method = "bray", data = urchin_density_master_sub)

#                         Df SumsOfSqs MeanSqs F.Model      R2 Pr(>F)    
# Site                     3    1.5287 0.50958  4.4120 0.10259  0.001 ***
# Protection.status        1    0.1528 0.15284  1.3233 0.01026  0.238    
# Herbivorous_fish         1    0.2279 0.22789  1.9730 0.01529  0.122    
# Urchin_predator          1    0.0681 0.06813  0.5899 0.00457  0.600    
# Site:Protection.status   3    1.0279 0.34264  2.9666 0.06898  0.006 ** 
# Residuals              103   11.8965 0.11550         0.79831           
# Total                  112   14.9021                 1.00000           


```

```{r plot ordination, fig.height=15, fig.width=15}
(urchin_ord_plot <-
  ggplot() + 
  geom_text(data=cDens.species.scores,aes(x=NMDS1,y=NMDS2,label=species), size = 8) +  # add the species labels
  geom_point(data=cDens.site.scores,aes(x=NMDS1,y=NMDS2,shape=Protection, colour=Site),size=6) + # add the point markers
  geom_polygon(data = hull_data,
               aes(x=NMDS1,y=NMDS2, colour = Site, linetype = Protection, group = Stratum),
               fill = NA, alpha = 1, size = 1.5) +  # Convex hulls
  scale_colour_manual(values=c("Hanauma" = "dodgerblue",
                               "Kaneohe" = "firebrick2",
                               "North Shore" = "gold",
                               "Waikiki" = "springgreen2"
                              )) +
  scale_linetype_manual(values = c("Protected" = "solid", "Unprotected" = "dashed")) +
  coord_equal() +
  theme_bw() + 
  theme(axis.title.x = element_text(size=22), 
        axis.title.y = element_text(size=22), 
        axis.text.x = element_text(size=20), 
        axis.text.y = element_text(size=20), 
        panel.background = element_blank(), 
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank(),
        legend.key.size = unit(2, "cm"), # increase legend size
        legend.text = element_text(size = rel(1.5)), # increase legend text
        legend.title = element_text(size = rel(1.5)),
        legend.position = 'bottom', # move legend to bottom
        legend.box = 'horizontal', # make legend horizontal
        legend.box.background = element_rect(colour = "black")) + # add box around legend
  guides(colour=guide_legend(title.position="top", # make color legend title go above legend
                                     title.hjust =0.5, nrow = 2),
         shape=guide_legend(title.position="top",  # make shape legend title go above legend
                                     title.hjust =0.5,
                            nrow = 2),
         linetype = guide_legend(title.position="top",  # make shape legend title go above legend
                                     title.hjust =0.5, override.aes = list(colour = "black")) # force linetype to appear in legend
         ) +
  scale_shape_manual(values = c(16, 1) )  + 
  geom_segment(data = env.scores,
                    aes(x = 0, xend = mult*NMDS1, y = 0, yend = mult*NMDS2),
                    arrow = arrow(length = unit(0.25, "cm")), colour = "grey") + # arrows for envfit.
       geom_text(data = env.scores, # labels the environmental variable arrows * "mult" as for the arrows
                 aes(x = mult*NMDS1, y = mult*NMDS2, label=env.variables),
                 size = 10,
                 hjust = 0) +
  geom_label(aes(x = 2, y = 2, label = "Stress = 0.07"), hjust = 1, size = 10) 
)

# ggsave(filename = "output/urchin_ordination_v2.png", urchin_ord_plot, height = 15, width = 15)
```

```{r bioerosion set up}
#### ECMA ----

# read in data from each paper for meta-analysis
bak_ECMA <- read.csv(here::here("erosion", "Bak_1990_ECMA.csv") )

mcmu_ECMA <- read.csv(here::here("erosion", "MCMU_1988_ECMA.csv"))

csmc_ECMA <- read.csv(here::here("erosion", "CSMC_2001_ECMA.csv"))

russo_ECMA <- read.csv(here::here("erosion", "Russo_1980_ECMA.csv"))

conand_ECMA <- read.csv(here::here("erosion", "Conand_1997_ECMA.csv"))

comb_ECMA <- rbind(bak_ECMA, csmc_ECMA, russo_ECMA, conand_ECMA)


# Bak 1990 fit
# No relationship reported in paper
# try exponential and power
bak_ECMA_mod_exp <- nls(ErosionRate_gPerDay ~ a * exp(b*Diameter_mm), data = bak_ECMA, start = list(a = 0.01, b = 0.04))
bak_ECMA_mod_trans <- nls(log(ErosionRate_gPerDay) ~ log(a) + b*Diameter_mm, data = bak_ECMA, start = list(a = 0.01, b = 0.04))
summary(bak_ECMA_mod_exp)
summary(bak_ECMA_mod_trans)
bak_ECMA_mod_power <- nls(ErosionRate_gPerDay ~ a*Diameter_mm^b, data = bak_ECMA, start = list(a = 0.01, b = 0.04))
AICc(bak_ECMA_mod_exp, bak_ECMA_mod_power) # power better
summary(bak_ECMA_mod_power) # similar to McClanahan re-fit
bak_ECMA_param <- summary(bak_ECMA_mod_power)$parameters

# McClanahan and Muthiga 1988 fit
# y = 0.27 + 0.012*(biomass)
# McClanahan 1988 biomass fit:
# y =  0.002(Diameter_mm)^2.64
mcmu_ECMA_mod_power <- nls(ErosionRate_gPerDay ~ a*Diameter_mm^b, data = mcmu_ECMA, start = list(a = 0.002, b = 2.6))
summary(mcmu_ECMA_mod_power) # parameters from fitting model using nls very different from paper

mcmu_ECMA_exp <- nls(ErosionRate_gPerDay ~ a * exp(b*Diameter_mm), data = mcmu_ECMA, start = list(a = 0.01, b = 0.04)) # try fitting to exponential
AICc(mcmu_ECMA_mod_power, mcmu_ECMA_exp) # power function still a better fit than exponential model

mcmu_ECMA_param <- summary(mcmu_ECMA_mod_power)$parameters


# CS and McC 2001 fit:
# y = 0.015*(biomass)
# McClanahan 1988 biomass fit:
# y =  0.002(Diameter_mm)^2.64
csmc_ECMA_mod_power <- nls(ErosionRate_gPerDay ~ a*Diameter_mm^b, data = csmc_ECMA, start = list(a = 0.002, b = 2.6))
summary(csmc_ECMA_mod_power) # parameters from fitting model using nls very different from paper

csmc_ECMA_exp <- nls(ErosionRate_gPerDay ~ a * exp(b*Diameter_mm), data = csmc_ECMA, start = list(a = 0.01, b = 0.04)) # try fitting to exponential
AICc(csmc_ECMA_mod_power, csmc_ECMA_exp) # power function still a better fit than exponential model

csmc_ECMA_param <- summary(csmc_ECMA_mod_power)$parameters

# VISUALIZE DIFFERENCE BETWEEN NLS MODEL FIT AND PAPER MODEL FIT
plot(x = csmc_ECMA$Diameter_mm, y = csmc_ECMA$ErosionRate_gPerDay)
curve(csmc_ECMA_param[1,1]*x^csmc_ECMA_param[2,1], add = TRUE, col = 'blue', lwd = 4) # NLS FIT
curve(0.015*0.002*x^2.64, add = TRUE, col = 'red', lwd = 4) # PAPER FIT
# NLS FIT CLEARLY BETTER



# russo fit
# ln(y) = 1.657*ln(diameter) + 3.622 reported in paper

russo_ECMA_mod_exp <- nls(ErosionRate_gPerDay ~ a * exp(b*Diameter_mm), data = russo_ECMA, start = list(a = 0.01, b = 0.04))
russo_ECMA_mod_trans <- nls(log(ErosionRate_gPerDay) ~ log(a) + b*Diameter_mm, data = russo_ECMA, start = list(a = 0.01, b = 0.04))
russo_ECMA_mod_power <- nls(ErosionRate_gPerDay ~ a*Diameter_mm^b, data = russo_ECMA, start = list(a = 0.01, b = 0.04))
AICc(russo_ECMA_mod_exp, russo_ECMA_mod_power) # power function is better despite being fit to exponential in paper
summary(russo_ECMA_mod_power) # similar results to the McClanahan re-fit
russo_ECMA_param <- summary(russo_ECMA_mod_power)$parameters

# VISUALIZE DIFFERENCE BETWEEN NLS MODEL FIT AND PAPER MODEL FIT
plot(x = russo_ECMA$Diameter_mm, y = russo_ECMA$ErosionRate_gPerDay)
curve(russo_ECMA_param[1,1]*x^russo_ECMA_param[2,1], add = TRUE, col = 'blue', lwd = 4) # NLS FIT
curve(3.622*exp(1.657*x), add = TRUE, col = 'red', lwd = 4) # PAPER FIT
# BASICALLY IDENTICAL FITS

# conand fit
# g_day = 0.000005*(Diameter_mm)^3.14 reported in paper
conand_ECMA_mod_power <- nls(ErosionRate_gPerDay ~ a*Diameter_mm^b, data = conand_ECMA, start = list(a = 0.002, b = 3.2))
conand_ECMA_mod_exp <- nls(ErosionRate_gPerDay ~ a * exp(b*Diameter_mm), data = conand_ECMA, start = list(a = 0.01, b = 0.04))
AICc(conand_ECMA_mod_power, conand_ECMA_mod_exp) # power funtion better
summary(conand_ECMA_mod_power) # different from paper
conand_ECMA_param <- summary(conand_ECMA_mod_power)$parameters

plot(x = conand_ECMA$Diameter_mm, y = conand_ECMA$ErosionRate_gPerDay)
curve(conand_ECMA_param[1,1]*x^conand_ECMA_param[2,1], add = TRUE, col = 'blue', lwd = 4) # NLS FIT
curve(0.000005*x^3.14, add = TRUE, col = 'red', lwd = 4) # PAPER FIT
# unclear which is better visually

AICc(lm(conand_ECMA$ErosionRate_gPerDay ~ I(conand_ECMA_param[1,1]*conand_ECMA$Diameter_mm^conand_ECMA_param[2,1])), # nls
     lm(conand_ECMA$ErosionRate_gPerDay ~ I(0.000005*conand_ECMA$Diameter_mm^3.14))) # paper fit

# nls model better
# moving forward with best fit model despite different parameters.


ECMA_data <- data.frame(
  Study = c("bak_ECMA", "conand_ECMA", "mcmu_ECMA", "csmc_ECMA", "russo_ECMA"),
  Model = c("Power", "Power", "Power", "Power", "Power"),  # Specify the model type
  Parameter_a = c(bak_ECMA_param[1, 1], conand_ECMA_param[1, 1], mcmu_ECMA_param[1, 1], csmc_ECMA_param[1, 1], russo_ECMA_param[1,1]),  # Extract 'a' parameter
  Parameter_b = c(bak_ECMA_param[2, 1], conand_ECMA_param[2, 1], mcmu_ECMA_param[2, 1],  csmc_ECMA_param[2, 1], russo_ECMA_param[2,1]),  # Extract 'b' parameter
  SE_Parameter_a = c(bak_ECMA_param[1, 2], conand_ECMA_param[1, 2], mcmu_ECMA_param[1, 2],  csmc_ECMA_param[1, 2], russo_ECMA_param[1,2]),  # Extract SE for 'a'
  SE_Parameter_b = c(bak_ECMA_param[2, 2], conand_ECMA_param[2,2], mcmu_ECMA_param[2, 2], csmc_ECMA_param[2,2], russo_ECMA_param[2,2]),  # Extract SE for 'b'
  Location = c("Moorea", "Reunion", "Kenya",  "Kenya", "Enewetak")
)

# run meta-analysis for b parameter
ECMA_meta_model_b <- rma(yi = Parameter_b, sei = SE_Parameter_b, data = ECMA_data)
forest(ECMA_meta_model_b)

# extract results
ECMA_meta_results_b <- summary(ECMA_meta_model_b)
ECMA_combined_effect_size_b <- ECMA_meta_results_b$beta
ECMA_sd_combined_effect_size_b <- sqrt(ECMA_meta_results_b$tau2) # extracting sd (tau)

# run meta-analysis for a parameter
ECMA_meta_model_a <- rma(yi = Parameter_a, sei = SE_Parameter_a, data = ECMA_data)
forest(ECMA_meta_model_a) # param values to small to visualize in forest plot

# extract results
ECMA_meta_results_a <- summary(ECMA_meta_model_a)
ECMA_combined_effect_size_a <- ECMA_meta_results_a$beta
ECMA_sd_combined_effect_size_a <- sqrt(ECMA_meta_results_a$tau2) # as above

# Add effect size estimates to dataframe for urchin bioerosion
ECMA <- subset(urchins_exp, Species.code == "ECMA")
ECMA$aE <- rep(ECMA_combined_effect_size_a, nrow(ECMA)) # specify a term for bioerosion estimate (aE) for ECMA
ECMA$bE <- rep(ECMA_combined_effect_size_b, nrow(ECMA)) # do the same for b
ECMA$aE_sd <- rep(ECMA_sd_combined_effect_size_a, nrow(ECMA)) # specify Sd from meta-analysis
ECMA$bE_sd <- rep(ECMA_sd_combined_effect_size_b, nrow(ECMA)) # do the same for b

#### DISA ----
bak_DISA <- read.csv(here::here("erosion", "Bak_1990_DISA.csv"))

csmc_DISA <- read.csv(here::here("erosion", "CSMC_2001_DISA.csv"))

# Bak 1990
# No relationship fitted in paper - midpoint size class used
bak_DISA_mod_exp <- nls(ErosionRate_gPerDay ~ a * exp(b*Diameter_mm), data = bak_DISA, start = list(a = 0.01, b = 0.04))

# linear gradient error for power function
# adding controls from https://stats.stackexchange.com/questions/599084/nls-singular-gradient-matrix-at-initial-parameter-estimates-error
bak_DISA_mod_power <- nls(ErosionRate_gPerDay ~ a*Diameter_mm^b, data = bak_DISA, start = list(a = 0.01, b = 1), control = list(minFactor = 2^(-16), maxiter = 1e4, warnOnly = TRUE))
AICc(bak_DISA_mod_exp, bak_DISA_mod_power) # power better
summary(bak_DISA_mod_power) # absolutely massive b parameter...
bak_DISA_param <- summary(bak_DISA_mod_power)$parameters


# CS and MC: y = 0.00001*(diameter_mm)^2.47
# based off biomass conversion
csmc_DISA_mod_power <- nls(ErosionRate_gPerDay ~ a*Diameter_mm^b, data = csmc_DISA, start = list(a = 0.002, b = 2.6))
summary(csmc_DISA_mod_power) # parameters from fitting model using nls different from paper

csmc_DISA_exp <- nls(ErosionRate_gPerDay ~ a * exp(b*Diameter_mm), data = csmc_DISA, start = list(a = 0.01, b = 0.04)) 
AICc(csmc_DISA_mod_power, csmc_DISA_exp) # power function still a better fit than exponential model

csmc_DISA_param <- summary(csmc_DISA_mod_power)$parameters



DISA_data <- data.frame(
  Study = c("bak_DISA", "csmc_DISA"),
  Model = c("Power", "Power"),  # Specify the model type
  Parameter_a = c(bak_DISA_param[1, 1], csmc_DISA_param[1, 1]),  # Extract 'a' parameter
  Parameter_b = c(bak_DISA_param[2, 1], csmc_DISA_param[2, 1]),  # Extract 'b' parameter
  SE_Parameter_a = c(bak_DISA_param[1, 2],  csmc_DISA_param[1, 2]),  # Extract SE for 'a'
  SE_Parameter_b = c(bak_DISA_param[2, 2], csmc_DISA_param[2,2])  # Extract SE for 'b'
)

# run meta-analysis for b parameter
DISA_meta_model_b <- rma(yi = Parameter_b, sei = SE_Parameter_b, data = DISA_data)
forest(DISA_meta_model_b) # huge error caused by issues with Bak
# extract results
DISA_meta_results_b <- summary(DISA_meta_model_b)
DISA_combined_effect_size_b <- DISA_meta_results_b$beta
DISA_sd_combined_effect_size_b <- sqrt(DISA_meta_results_b$tau2)

# run meta-analysis for a parameter
DISA_meta_model_a <- rma(yi = Parameter_a, sei = SE_Parameter_a, data = DISA_data)
forest(DISA_meta_model_a) 
# extract results
DISA_meta_results_a <- summary(DISA_meta_model_a)
DISA_combined_effect_size_a <- DISA_meta_results_a$beta
DISA_sd_combined_effect_size_a <- sqrt(DISA_meta_results_a$tau2)

# create new df
DISA <- subset(urchins_exp, Species.code == "DISA")
DISA$aE <- rep(DISA_combined_effect_size_a, nrow(DISA)) # specify a term for bioerosion estimate (aE) for DISA
DISA$bE <- rep(DISA_combined_effect_size_b, nrow(DISA)) # do the same for b
DISA$aE_sd <- rep(DISA_sd_combined_effect_size_a, nrow(DISA)) # specify SE from meta-analysis
DISA$bE_sd <- rep(DISA_sd_combined_effect_size_b, nrow(DISA)) # do the same for b


#### ECAC ----
# ln(y) = 2.713*ln(diameter) + 3.619
russo_ECAC <- read.csv(here::here("erosion", "Russo_1980_ECAC.csv"))
russo_ECAC_mod_power <- nls(ErosionRate_gPerDay ~ a*Diameter_mm^b, data = russo_ECAC, start = list(a = 0.01, b = 0.04))
summary(russo_ECAC_mod_power)

russo_ECAC_mod_exp <- nls(ErosionRate_gPerDay ~ a * exp(b*Diameter_mm), data = russo_ECAC, start = list(a = 0.01, b = 0.04))
AICc(russo_ECAC_mod_power, russo_ECAC_mod_exp)
 
russo_ECAC_param <- summary(russo_ECAC_mod_power)$parameters


# Going through the motions of the meta-analysis even though there's only one paper. Should be the same results

ECAC_data <- data.frame(
  Study = c("russo_ECAC"),
  Model = c("Exponential"),  # Specify the model type
  Parameter_a = c(russo_ECAC_param[1,1]),  # Extract 'a' parameter
  Parameter_b = c(russo_ECAC_param[2,1]),  # Extract 'b' parameter
  SE_Parameter_a = c(russo_ECAC_param[1,2]),  # Extract SE for 'a'
  SE_Parameter_b = c(russo_ECAC_param[2,2])  # Extract SE for 'b'
)


# run meta-analysis for b parameter
ECAC_meta_model_b <- rma(yi = Parameter_b, sei = SE_Parameter_b, data = ECAC_data)
forest(ECAC_meta_model_b)
# extract results
ECAC_meta_results_b <- summary(ECAC_meta_model_b)
ECAC_combined_effect_size_b <- ECAC_meta_results_b$beta
ECAC_sd_combined_effect_size_b <- sqrt(ECAC_meta_results_b$tau2)

# run meta-analysis for a parameter
ECAC_meta_model_a <- rma(yi = Parameter_a, sei = SE_Parameter_a, data = ECAC_data)
forest(ECAC_meta_model_a) 
# extract results
ECAC_meta_results_a <- summary(ECAC_meta_model_a)
ECAC_combined_effect_size_a <- ECAC_meta_results_a$beta
ECAC_sd_combined_effect_size_a <- sqrt(ECAC_meta_results_a$tau2)

# create new df
ECAC <- subset(urchins_exp, Species.code == "ECAC")
ECAC$aE <- rep(ECAC_combined_effect_size_a, nrow(ECAC)) # specify a term for bioerosion estimate (aE) for ECAC
ECAC$bE <- rep(ECAC_combined_effect_size_b, nrow(ECAC)) # do the same for b
ECAC$aE_sd <- rep(ECAC_sd_combined_effect_size_a, nrow(ECAC)) # specify SE from meta-analysis
ECAC$bE_sd <- rep(ECAC_sd_combined_effect_size_b, nrow(ECAC)) # do the same for b

#### ECDI ----
bak_ECDI <- read.csv(here::here("erosion", "Bak_1994_ECDI.csv"))
# Bak 1990
# No relationship fitted in paper - midpoint size class used
bak_ECDI_mod_exp <- nls(ErosionRate_gPerDay ~ a * exp(b*Diameter_mm), data = bak_ECDI, start = list(a = 0.01, b = 0.04))

# linear gradient error for power function
# adding controls 
bak_ECDI_mod_power <- nls(ErosionRate_gPerDay ~ a*Diameter_mm^b, data = bak_ECDI, start = list(a = 0.01, b = 1), control = list(minFactor = 2^(-16), maxiter = 1e4, warnOnly = TRUE))
AICc(bak_ECDI_mod_exp, bak_ECDI_mod_power) # AICc = inf for both. not enough data. going with power model.
summary(bak_ECDI_mod_power) 
bak_ECDI_param <- summary(bak_ECDI_mod_power)$parameters

# cs-mc found 0.005*body weight but they don't have bodyweight conversion data in paper or in McClanahan 1988
# Just going to move forwad with bak parameters

# Going through the motions of the meta-analysis even though there's only one paper. Should be the same results

ECDI_data <- data.frame(
  Study = c("bak_ECDI"),
  Model = c("Power"),  # Specify the model type
  Parameter_a = c(bak_ECDI_param[1,1]),  # Extract 'a' parameter
  Parameter_b = c(bak_ECDI_param[2,1]),  # Extract 'b' parameter
  SE_Parameter_a = c(bak_ECDI_param[1,2]),  # Extract SE for 'a'
  SE_Parameter_b = c(bak_ECDI_param[2,2])  # Extract SE for 'b'
)


# run meta-analysis for b parameter
ECDI_meta_model_b <- rma(yi = Parameter_b, sei = SE_Parameter_b, data = ECDI_data)
forest(ECDI_meta_model_b)
# extract results
ECDI_meta_results_b <- summary(ECDI_meta_model_b)
ECDI_combined_effect_size_b <- ECDI_meta_results_b$beta
ECDI_sd_combined_effect_size_b <- sqrt(ECDI_meta_results_b$tau2)

# run meta-analysis for a parameter
ECDI_meta_model_a <- rma(yi = Parameter_a, sei = SE_Parameter_a, data = ECDI_data)
# extract results
ECDI_meta_results_a <- summary(ECDI_meta_model_a)
ECDI_combined_effect_size_a <- ECDI_meta_results_a$beta
ECDI_sd_combined_effect_size_a <- sqrt(ECDI_meta_results_a$tau2)

# create new df
ECDI <- subset(urchins_exp, Species.code == "ECDI")
ECDI$aE <- rep(ECDI_combined_effect_size_a, nrow(ECDI)) # specify a term for bioerosion estimate (aE) for ECDI
ECDI$bE <- rep(ECDI_combined_effect_size_b, nrow(ECDI)) # do the same for b
ECDI$aE_sd <- rep(ECDI_sd_combined_effect_size_a, nrow(ECDI)) # specify SE from meta-analysis
ECDI$bE_sd <- rep(ECDI_sd_combined_effect_size_b, nrow(ECDI)) # do the same for b

#### Other urchins ----
# echinometra oblonga - use ECMA constant
ECOB <- subset(urchins_exp, Species.code == "ECOB")
ECOB$aE <- rep(ECMA_combined_effect_size_a, nrow(ECOB)) # specify a term for bioerosion estimate (aE) for ECMA
ECOB$bE <- rep(ECMA_combined_effect_size_b, nrow(ECOB)) # do the same for b
ECOB$aE_sd <- rep(ECMA_sd_combined_effect_size_a, nrow(ECOB)) # specify SE from meta-analysis
ECOB$bE_sd <- rep(ECMA_sd_combined_effect_size_b, nrow(ECOB)) # do the same for b




# Echinothrix calamaris - use Echinotrhix diadema constant
# Use effect sizes to estimate urchin bioerosion
ECCA <- subset(urchins_exp, Species.code == "ECCA")
ECCA$aE <- rep(ECDI_combined_effect_size_a, nrow(ECCA)) # specify a term for bioerosion estimate (aE) for ECCA
ECCA$bE <- rep(ECDI_combined_effect_size_b, nrow(ECCA)) # do the same for b
ECCA$aE_sd <- rep(ECDI_sd_combined_effect_size_a, nrow(ECCA)) # specify SE from meta-analysis
ECCA$bE_sd <- rep(ECDI_sd_combined_effect_size_b, nrow(ECCA)) # do the same for b



# Diadema paucispinum - use DISA constant
DIPA <- subset(urchins_exp, Species.code == "DIPA")
DIPA$aE <- rep(DISA_combined_effect_size_a, nrow(DIPA)) # specify a term for bioerosion estimate (aE) for DIPA
DIPA$bE <- rep(DISA_combined_effect_size_b, nrow(DIPA)) # do the same for b
DIPA$aE_sd <- rep(DISA_sd_combined_effect_size_a, nrow(DIPA)) # specify SE from meta-analysis
DIPA$bE_sd <- rep(DISA_sd_combined_effect_size_b, nrow(DIPA)) # do the same for b





# rebuild urchins dataframe with all species and erosion coefficients/errors
# not including TRGR, HEMA, or EUMA because of no available estimates of bioerosion from conspecifics
# they all had relatively low abundance and TRGR & HEMA have low hypothesized rates of erosion
urchin_update <- rbind(ECMA, DIPA, DISA, ECAC, ECCA, ECDI, ECOB)
urchin_update$Bioerosion <- urchin_update$aE*urchin_update$biomass.ind^urchin_update$bE

# condense by transect
urchin_erosion <- ddply(urchin_update,
                        c("Site","Site.ID", "Protection.status", "Substrate", "Transect.number"), numcolwise(sum)) 
urchin_erosion_master <- merge(urchin_erosion, simplified_benthic,
                               by = c("Site","Site.ID", "Protection.status", "Substrate", "Transect.number"))
# add Depth_m, Herbivorous_fish, and Urchin_predators
urchin_erosion_master$Depth_m <- urchin_guild_master$Depth_m
urchin_erosion_master$Herbivorous_fish <- urchin_guild_master$Herbivorous_fish
urchin_erosion_master$Urchin_predator <- urchin_guild_master$`Urchin predator`
```

```{r erosion model}
erosion_mod <- glmmTMB(Bioerosion ~ Protection.status*Site + Herbivorous_fish + Urchin_predator,
           data = urchin_erosion_master, family = ziGamma(link = "log"), 
           ziformula = ~  Site) 
plot(simulateResiduals(erosion_mod)) # no problems detected
summary(erosion_mod)
# Zero-inflation model:
#                   Estimate Std. Error z value Pr(>|z|)    
# (Intercept)     -2.512e+00  6.003e-01  -4.185 2.85e-05 ***
# SiteKaneohe      3.749e+00  7.097e-01   5.282 1.28e-07 ***
# SiteNorth Shore  1.157e-05  8.490e-01   0.000    1.000    
# SiteWaikiki     -1.714e+01  3.377e+03  -0.005    0.996   
Anova(erosion_mod)
#                          Chisq Df Pr(>Chisq)    
# Protection.status       2.0571  1    0.15150    
# Site                   61.6569  3  2.601e-13 ***
# Herbivorous_fish        2.7950  1    0.09456 .  
# Urchin_predator         0.0131  1    0.90873    
# Protection.status:Site 41.9704  3  4.071e-09 ***

```

```{r erosion plot setup}
# Protection and site
emmeans(erosion_mod, pairwise ~ Protection.status | Site)
# Site = Hanauma:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected    1.633 0.709 Inf   2.302  0.0213
# 
# Site = Kaneohe:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -3.529 1.290 Inf  -2.733  0.0063
# 
# Site = North Shore:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected    0.224 0.576 Inf   0.388  0.6979
# 
# Site = Waikiki:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -3.150 0.670 Inf  -4.705  <.0001
erosion_protection_symb <- c("*", "**", "", "***")


# herb
erosion_herb_data <- emmip(erosion_mod, ~ Herbivorous_fish, at = list(Herbivorous_fish = seq(0,10,0.01)), CIs = T, plotit = F)
erosion_herb_data$Guild <- rep("erosion", nrow(erosion_herb_data)) # add guild column for plot
erosion_herb_data$Bioerosion <- exp(erosion_herb_data$yvar) # back transform model fit to response scale
erosion_herb_data$lower.CI <- exp(erosion_herb_data$LCL) # repeat for 95% CI
erosion_herb_data$upper.CI <- exp(erosion_herb_data$UCL)

# filter ranges
erosion_herb_data <- erosion_herb_data %>%
  dplyr::filter(Herbivorous_fish >= min(urchin_erosion_master$Herbivorous_fish) &
                  Herbivorous_fish <= max(urchin_erosion_master$Herbivorous_fish))


# pred
erosion_pred_data <- emmip(erosion_mod, ~ Urchin_predator, at = list(Urchin_predator = seq(0,1,0.001)), CIs = T, plotit = F)
erosion_pred_data$Guild <- rep("erosion", nrow(erosion_pred_data)) # add guild column for plot
erosion_pred_data$Bioerosion <- exp(erosion_pred_data$yvar) # back transform model fit to response scale
erosion_pred_data$lower.CI <- exp(erosion_pred_data$LCL) # repeat for 95% CI
erosion_pred_data$upper.CI <- exp(erosion_pred_data$UCL)

# filter ranges
erosion_pred_data <- erosion_pred_data %>%
  dplyr::filter(Urchin_predator >= min(urchin_erosion_master$Urchin_predator) &
                  Urchin_predator <= max(urchin_erosion_master$Urchin_predator))

```

```{r plot erosion factors, fig.height=5, fig.width=8}
(erosion_site_plot <-
   ggplot() +
   geom_boxplot(data = urchin_erosion_master, aes(x = Site, y = Bioerosion, fill = Protection.status), outlier.shape = NA) +
   geom_point(data = urchin_erosion_master, aes(x = Site, y = Bioerosion, fill = Protection.status),
              position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0.3)) +
   geom_text(aes(x = c(1, 2, 3, 4), y = rep(5700, 4), label = erosion_protection_symb), size = 15) + # add sig stars
    scale_fill_manual(values = c("Protected" = "grey",
                      "Unprotected" = "white")) +
    scale_y_continuous(limits = c(0, 6200)) +
    labs(title = "a. Site", fill = "Protection status", y = bquote('Erosion rate (mg '*day^-1*')'), x = "" ) +
   my_theme
  )


(herb_plot <-
  ggplot() +
   geom_point(data = urchin_erosion_master, aes(x = Herbivorous_fish, y = Bioerosion)) +
   geom_line(data = erosion_herb_data, aes(x = Herbivorous_fish, y = Bioerosion), size = 1.5) +
   geom_ribbon(data = erosion_herb_data, aes(x = Herbivorous_fish, ymin = lower.CI, ymax = upper.CI), alpha = 0.5) +
   geom_text(aes(x = 0, y = 5000, label = "P = 0.09"), hjust = 0, size = 8) +
   labs(title = "b. Herbivorous fish", y = "",
        x = bquote('Herbivore biomass (g '*m^-2*')')) +
   my_theme 
 )

(pred_plot <-
  ggplot() +
   geom_point(data = urchin_erosion_master, aes(x = Urchin_predator, y = Bioerosion)) +
   geom_line(data = erosion_pred_data, aes(x = Urchin_predator, y = Bioerosion), size = 1.5) +
   geom_ribbon(data = erosion_pred_data, aes(x = Urchin_predator, ymin = lower.CI, ymax = upper.CI), alpha = 0.5) +
   geom_text(aes(x = 0, y = 5000, label = "P = 0.91"), hjust = 0, size = 8) +
   labs(title = "c. Urchin predators", y = "",
        x = bquote('Predator biomass (g '*m^-2*')')) +
   my_theme 
 )

```

```{r erosion panel graph, fig.height = 6, fig.width = 19}
(erosion_panel <- ggarrange(erosion_site_plot, herb_plot, pred_plot,
          nrow = 1, ncol = 3, common.legend = T, legend = "bottom", widths = c(0.4, 0.3, 0.3)))

# ggsave(filename = "output/erosion_panel_v2.png", erosion_panel, height = 6, width = 19)
```