---
title: "urchin_bioerosion"
author: "Noam Altman-Kurosaki"
date: "2024-10-21"
output: html_document
---

```{r setup, include=FALSE}
rm(list=ls()) # clean up
library(knitr)
library(plyr)
library(car)
library(reshape)
library(reshape2)
library(effects)
library(MASS)
library(tidyr)
library(MuMIn)
library(mgcv)
library(sp)
library(vegan)
library(ggplot2)
library(ggbreak)
library(ggpubr)
library(glmmTMB)
library(emmeans)
library(DHARMa)
library(metafor) # for metaanalysis
library(stringr)
library(here)
opts_chunk$set(comment="  ",
               collapse=TRUE, 
               echo=FALSE,
               #fig.asp=1/gr,
               fig.height=8,
               fig.width = 10,
               dev="png",
               warning=TRUE
               
               )
options("print.matrix" = FALSE)
opts_knit$set(eval.after = "fig.cap") 
```

```{r functions}
# create function for standard error
se = function(x){
  sd(x, na.rm = TRUE)/sqrt(length(x))
}

weighted.var.se <- function(x, w, na.rm=FALSE)
#  Computes the variance of a weighted mean following Cochran 1977 definition
{
  if (na.rm) { w <- w[i <- !is.na(x)]; x <- x[i] }
  n = length(w)
  xWbar = weighted.mean(x,w,na.rm=na.rm)
  wbar = mean(w)
  out = n/((n-1)*sum(w)^2)*(sum((w*x-wbar*xWbar)^2)-2*xWbar*sum((w-wbar)*(w*x-wbar*xWbar))+xWbar^2*sum((w-wbar)^2))
  return(out)
}

##start copy here for function pairwise.adonis()
pairwise.adonis <- function(x,factors, sim.function = 'vegdist', sim.method = 'bray', p.adjust.m ='bonferroni')
{
library(vegan)

co = combn(unique(as.character(factors)),2)
pairs = c()
F.Model =c()
R2 = c()
p.value = c()


for(elem in 1:ncol(co)){
if(sim.function == 'daisy'){
library(cluster); x1 = daisy(x[factors %in% c(co[1,elem],co[2,elem]),],metric=sim.method)
} else{x1 = vegdist(x[factors %in% c(co[1,elem],co[2,elem]),],method=sim.method)}

ad = adonis(x1 ~ factors[factors %in% c(co[1,elem],co[2,elem])] );
pairs = c(pairs,paste(co[1,elem],'vs',co[2,elem]));
F.Model =c(F.Model,ad$aov.tab[1,4]);
R2 = c(R2,ad$aov.tab[1,5]);
p.value = c(p.value,ad$aov.tab[1,6])
}
p.adjusted = p.adjust(p.value,method=p.adjust.m)
sig = c(rep('',length(p.adjusted)))
sig[p.adjusted <= 0.05] <-'.'
sig[p.adjusted <= 0.01] <-'*'
sig[p.adjusted <= 0.001] <-'**'
sig[p.adjusted <= 0.0001] <-'***'

pairw.res = data.frame(pairs,F.Model,R2,p.value,p.adjusted,sig)
print("Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1")
return(pairw.res)

} 

## end copy here


#dispersion parameter function
overdis = function(model) {
  sum(residuals(model, type = "pearson")^2)/(length(model$y) - length(model$coefficients))
}

# truncated normal - from https://stats.stackexchange.com/questions/113230/generate-random-numbers-following-a-distribution-within-an-interval
rtruncnorm <- function(N, mean = 0, sd = 1, a = -Inf, b = Inf) {
  if (a > b) stop('Error: Truncation range is empty');
  U <- runif(N, pnorm(a, mean, sd), pnorm(b, mean, sd));
  qnorm(U, mean, sd); }

```

```{r read in herbs}

# read in data
comb <- read.csv(here::here("data", "urchin_data.csv"), stringsAsFactors = T)
comb$Species.code <- str_trim(comb$Species.code) # remove any excess spaces from the end of species codes
levels(as.factor(comb$Species.code))


comb$Size <- as.numeric(comb$Size) # coerce size into as numeric
comb$SL <- comb$aL + comb$bL * comb$Size # convert TL to SL for biomass conversions
comb$biomass.ind <- comb$a * comb$SL^comb$b # biomass = aL^b
comb$Rugosity <- 10/comb$Rugosity # convert rugosity to rugosity index over 10m

# Only interested in urchins (community of interest), herbivorous fish (competitors), urchin predators
relevant_data <- subset(comb, Diet == "Herbivore" | Diet == "Urchin" | Diet == "Urchin predator") 

relevant_data_exp <- untable(relevant_data, relevant_data$Count) # expand table so each row is an individual urchin
zeroes <- subset(relevant_data, Count == 0)  # Retain transects with no individuals of a given species
urchins_zeroes <- subset(zeroes, Diet == "Urchin") # Specifically keep urchin species from the zero transects
urchins_exp <- subset(relevant_data_exp, Diet == 'Urchin') # subset urchins from expanded table

# randomly sample urchins to from existing size distributions to fill in "just count" urchins
set.seed(1032)
for(i in 1:nrow(urchins_exp)){ # for each individual
  if(is.na(urchins_exp$Size[i])){ # if the size is an NA it was an usized count
    urchins_exp$Size[i] = replace_na(urchins_exp$Size[i], # replace that NA
                                      sample(subset(urchins_exp, # by sampling randomly from the expanded dataframe
                                                    !is.na(urchins_exp$Size) & # using urchins that WERE sized/not NAs
                                                      Species.code == urchins_exp$Species.code[i] & # specifically of that species
                                                      Site.ID == urchins_exp$Site.ID[i])$Size, size = 1)) # and from that transect
    
  }
}
urchins_exp <- rbind(urchins_exp, urchins_zeroes) # re-attach zero value transects
# recalculate biomass
urchins_exp$SL <- urchins_exp$aL + urchins_exp$bL*urchins_exp$Size # convert TL to SL for biomass conversions, or urchin test diam from cm to mm
urchins_exp$biomass.ind <- urchins_exp$a * urchins_exp$SL^urchins_exp$b # biomass = aL^b
urchins_exp$Depth_m <- urchins_exp$Depth/3.281 # convert depth from ft to m

# read benthic data
benthic <- read.csv(here::here("data", "benthic_data.csv"))
benthic <- aggregate(. ~ Date+Site.ID+Site+Protection.status+Substrate, data = benthic, FUN = mean)
benthic_meta <- c("Date", "Site.ID", "Site", "Protection.status", "Substrate", "Transect.number", "Depth")


# simplify
# sum up by broader taxonomic group
coral_list <- c('CyphAga', 'LPurp','MCAP','MFLAB','MPATU','PCOM', 'PDAM', 'PEVER','P.mass','PMEAN','PVAR','Soft.coral')
coral <- rowSums(benthic[,coral_list])
invert_list <- c('mob', 'OTH.SINV', 'PALYTHO', 'Tunicate')
invert <- rowSums(benthic[,invert_list])
sponges <- benthic$Prfa
turf <- rowSums(benthic[,c('TURFH', 'RTA')])
sndyTurf <- benthic$SndyTrf
sand <- benthic$Sand
CCA <- benthic$CCA
green_macro_list <- c('HADI','Neo_spp', 'DCav', 'DVers')
green_macro <- rowSums(benthic[,green_macro_list])
brown_macro <- benthic$Dicsp
red_macro_list <- c('Acan', 'ALGA', 'ASPAR', 'GAL', 'GSAL', 'LIA','RAUE', 'LIA', 'KAPPA', 'PRWE', 'RAUE', 'TolyGlom')
red_macro <- rowSums(benthic[,red_macro_list])
cyano_list <- c('CYANO_Sub', 'Lyn_spp')
large_cyano <- rowSums(benthic[,cyano_list])

simplified_benthic <- data.frame(Coral = coral,
                            Invert = invert,
                            Turf = turf,
                            sndyTurf = sndyTurf,
                            Sponges = sponges,
                            Sand = sand,
                            CCA = CCA,
                            Green_Macro = green_macro,
                            Brown_Macro = brown_macro,
                            Red_Macro = red_macro,
                         Large_Cyano = large_cyano)

# simplify macroalgae
simplified_benthic$Macroalgae <- simplified_benthic$Red_Macro + simplified_benthic$Brown_Macro + simplified_benthic$Green_Macro

# simplify turf category
simplified_benthic$Simple_turf <- simplified_benthic$Turf + simplified_benthic$sndyTurf

# turn into proportion
simplified_benthic <- simplified_benthic/100

# add back in metadata
simplified_benthic <- cbind(benthic[,benthic_meta], simplified_benthic)

# create transformed df for ordination later
cover_columns <- colnames(simplified_benthic)[-which(names(simplified_benthic) %in% benthic_meta)]
benthic_trans <- simplified_benthic
benthic_trans[cover_columns] <- lapply(benthic_trans[cover_columns], function(x) asin(sqrt(x)))


```


```{r count analyses set up}
# aggregate counts to get total number of ind for each species per transect
comb_count <- ddply(relevant_data, c("Site","Site.ID", "Protection.status", "Substrate", "Guild", "Species.code", "Species.name", "Transect.number", "Transect.area", "Depth", "Rugosity", "Diet"), numcolwise(sum))

# calculate density for fish and urchins (different size transects) then recombine
fish <- subset(comb_count, Diet != 'Urchin')
fish$Density <- fish$Count/fish$Transect.area # density = count / area (fish were on a 25 x 5 m transect)
urchins <- subset(comb_count, Diet == 'Urchin')
urchins$Density <- urchins$Count/urchins$Transect.area # urchins were on a 25 x 2 m transect
comb_count <- rbind(fish, urchins) # recombine them

# create wide table at functional group level
guild_density_multi <- cast(comb_count, Site + Site.ID + Protection.status + Substrate + Transect.number + Depth + Rugosity ~ Guild, fun.aggregate = sum, value = "Density")
guild_density_multi$Herbivorous_fish <- guild_density_multi$Scraper + guild_density_multi$Browser + guild_density_multi$Grazer

# for modeling on poisson with offset
guild_count_multi <- cast(comb_count, Site + Site.ID + Protection.status + Substrate + Transect.number + Depth + Rugosity ~ Guild, fun.aggregate = sum, value = "Count") 

guild_count_multi$Herbivorous_fish <- guild_count_multi$Scraper + guild_count_multi$Browser + guild_count_multi$Grazer




# create wide table at species level
species_density_multi <- cast(comb_count, Site + Site.ID + Protection.status + Substrate + Transect.number + Depth + Rugosity ~ Species.name, fun.aggregate = sum, value = "Density")

# create wide table for urchin density
urchin_density_multi <- cast(urchins, Site + Site.ID + Protection.status + Substrate + Transect.number + Depth + Rugosity ~ Species.name, fun.aggregate = sum, value = "Density")


urchin_density_master <- merge(urchin_density_multi, simplified_benthic)


# for guild density
urchin_guild_master <- merge(guild_density_multi, simplified_benthic) 

hist(urchin_guild_master$`Boring urchin`)
hist(urchin_guild_master$`Grazing urchin`)



# correlations
pairs(~ `Boring urchin` + `Grazing urchin` + Simple_turf + Coral + Macroalgae + CCA + Depth + Rugosity, data = urchin_guild_master)
pairs(~ `Boring urchin` + `Grazing urchin` + Scraper + Grazer + Depth + Rugosity + `Urchin predator` + Herbivorous_fish, data = guild_count_multi)

```

```{r grazing urchin model selection}
# coerce grazing and boring urchins back to integers for modeling by multiplying by transect area
urchin_guild_master$grazing_urchin <- urchin_guild_master$`Grazing urchin`*50
urchin_guild_master$boring_urchin <- urchin_guild_master$`Boring urchin`*50

grazing_pois <- glmmTMB(grazing_urchin ~ Protection.status*Site + Simple_turf + Coral + Macroalgae + CCA + Depth + Herbivorous_fish + `Urchin predator`, family = poisson, data = urchin_guild_master) 
plot(simulateResiduals(grazing_pois)) # overdispersed, non-normal residuals, fails heterogeneity of variance

grazing_nb <- glmmTMB(grazing_urchin ~ Protection.status*Site + Simple_turf + Coral + Macroalgae + CCA + Depth + Herbivorous_fish + `Urchin predator`, family = nbinom2(), data = urchin_guild_master) 
plot(simulateResiduals(grazing_nb)) # no issues

grazing_zi <- glmmTMB(grazing_urchin ~ Protection.status*Site + Simple_turf + Coral + Macroalgae + CCA + Depth + Herbivorous_fish + `Urchin predator`, ziformula = ~Site, family = nbinom2(), data = urchin_guild_master)
plot(simulateResiduals(grazing_zi)) # no issues

AICc(grazing_pois, grazing_nb, grazing_zi) # negative bimomial has best AIC by ~9 over zero inflated despite issues

summary(grazing_nb)
Anova(grazing_nb)
#                          Chisq Df Pr(>Chisq)    
# Protection.status       4.8237  1   0.028071 *  
# Site                   71.4697  3  2.068e-15 ***
# Simple_turf             0.9275  1   0.335511    
# Coral                  16.0637  1  6.125e-05 ***
# Macroalgae              3.9866  1   0.045862 *  
# CCA                     0.9767  1   0.323021    
# Depth                   8.3665  1   0.003822 ** 
# Herbivorous_fish        5.1022  1   0.023895 *  
# `Urchin predator`       2.0896  1   0.148304    
# Protection.status:Site  2.1387  3   0.544124    

emmeans(grazing_nb, pairwise ~ Protection.status | Site)
# $contrasts
# Site = Hanauma:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -0.276 0.545 Inf  -0.507  0.6119
# 
# Site = Kaneohe:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected    0.163 1.447 Inf   0.113  0.9104
# 
# Site = North Shore:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -0.985 0.501 Inf  -1.965  0.0495
# 
# Site = Waikiki:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -1.071 0.557 Inf  -1.925  0.0542
grazing_dens_sig <- c("", "", "*", "")
```

```{r boring model selection}

boring_pois <- glmmTMB(boring_urchin ~ Protection.status*Site + Simple_turf + Coral + Macroalgae + CCA + Depth + Herbivorous_fish + `Urchin predator`, family = poisson, data = urchin_guild_master) 
plot(simulateResiduals(boring_pois)) # looks bad

boring_nb <- glmmTMB(boring_urchin ~ Protection.status*Site + Simple_turf + Coral + Macroalgae + CCA + Depth + Herbivorous_fish + `Urchin predator`, family = nbinom2(), data = urchin_guild_master) 
plot(simulateResiduals(boring_nb)) # overdispersed, positive trend in quantile residual tests

boring_zi <- glmmTMB(boring_urchin ~ Protection.status*Site + Simple_turf + Coral + Macroalgae + CCA + Depth + Herbivorous_fish + `Urchin predator`, ziformula = ~Site, family = nbinom2(), data = urchin_guild_master)
plot(simulateResiduals(boring_zi)) # no problems detected

AICc(boring_pois, boring_nb, boring_zi) # zero inflated best by > 70 over nb

summary(boring_zi)
# Zero-inflation model:
#                  Estimate Std. Error z value Pr(>|z|)    
# (Intercept)      -2.51808    0.60353  -4.172 3.02e-05 ***
# SiteKaneohe       3.65508    0.72036   5.074 3.90e-07 ***
# SiteNorth Shore  -0.01037    0.85765  -0.012    0.990    
# SiteWaikiki     -11.61689  214.19512  -0.054    0.957  

Anova(boring_zi)
#                          Chisq Df Pr(>Chisq)    
# Protection.status       6.6999  1   0.009642 ** 
# Site                   11.6422  3   0.008715 ** 
# Simple_turf            24.2928  1  8.275e-07 ***
# Coral                   8.5145  1   0.003523 ** 
# Macroalgae              1.4179  1   0.233755    
# CCA                     0.1412  1   0.707091    
# Depth                   2.5080  1   0.113269    
# Herbivorous_fish        1.5385  1   0.214839    
# `Urchin predator`       1.2538  1   0.262825    
# Protection.status:Site 31.1702  3  7.827e-07 ***

# pairwise comparisons for site and protection status interaction
emmeans(boring_zi, pairwise ~ Protection.status | Site)
# Site = Hanauma:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -0.756 0.326 Inf  -2.316  0.0205
# 
# Site = Kaneohe:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -2.586 0.801 Inf  -3.230  0.0012
# 
# Site = North Shore:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected    0.556 0.283 Inf   1.967  0.0491
# 
# Site = Waikiki:
#  contrast                estimate    SE  df z.ratio p.value
#  Protected - Unprotected   -1.306 0.329 Inf  -3.963  0.0001

boring_dens_sig <- c("*", "**", "*", "***")
```

```{r protection density boxplots, fig.height= 5, fig.width = 8}
(grazing_density_plot <-
   ggplot() +
   geom_boxplot(data = urchin_guild_master, aes(x = Site, y = grazing_urchin, fill = Protection.status)) +
   geom_text(aes(x = c(1, 2, 3, 4), y = rep(45, 4), label = grazing_dens_sig), size = 15) + # add sig stars
   scale_y_break(c(50, 200), space = 0.5) +
    scale_fill_manual(values = c("Protected" = "grey",
                      "Unprotected" = "white")) +
    labs(title = "a. Grazing urchin density", fill = "Protection status", y = bquote('Density (per 50('*m^2*') transect)') ) +
    theme_classic() +
      theme(axis.title.x = element_text(size=24, colour = "black"), 
        axis.title.y = element_text(size=24, colour = "black"), 
        axis.text.x = element_text(size=22, colour = "black"), 
        axis.text.y = element_text(size=22, colour = "black"),
        legend.text = element_text(size=22, colour = "black"),
        plot.title = element_text(size=26), 
        panel.background = element_blank(), 
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_rect(fill = "white"),
        legend.title = element_blank(),
        legend.position = 'null', # move legend to bottom
        legend.box = 'horizontal', # make legend horizontal
        legend.box.background = element_rect(colour = "black"))  # add box around legend
  )
   

(boring_density_plot <-
   ggplot() +
    geom_boxplot(data = urchin_guild_master, aes(x = Site, y = boring_urchin, fill = Protection.status)) +
    geom_text(aes(x = c(1, 2, 3, 4), y = rep(600, 4), label = boring_dens_sig), size = 15) +
    scale_fill_manual(values = c("Protected" = "grey",
                      "Unprotected" = "white")) +
    labs(title = "e. Boring urchin density", fill = "Protection status", y = bquote('Density (per 50('*m^2*') transect)') ) +
    theme_classic() +
      theme(axis.title.x = element_text(size=24, colour = "black"), 
        axis.title.y = element_text(size=24, colour = "black"), 
        axis.text.x = element_text(size=22, colour = "black"), 
        axis.text.y = element_text(size=22, colour = "black"),
        legend.text = element_text(size=22, colour = "black"),
        plot.title = element_text(size=26), 
        panel.background = element_blank(), 
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_rect(fill = "white"),
        legend.title = element_blank(),
        legend.position = 'bottom', # move legend to bottom
        legend.box = 'horizontal', # make legend horizontal
        legend.box.background = element_rect(colour = "black"))  # add box around legend
  )
   

```

```{r density emtrends}
# Simple_turf

# Coral

# Macroalgae

# CCA

# Depth

# Herbivorous_fish

# `Urchin predator`

```